<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
        <style>
          h1,h2,h3,h4,h5,h6 { text-transform: none !important;}
          section.left { text-align: left; }
        </style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides" data-separator-notes="^Notes:">
				<section data-markdown>
                # Monadic Parsers
                # at the
                # Input Boundary

                James Brock

                PureConf 2022 February 18
                </section>
                <section>
                  <p>Serializing to a byte stream is easy.</p>
                  <p>Deserializing from a byte stream is hard, because of <b>alternative</b> and <b>failure</b>.</p>
                  <table>
                    <tbody>
                      <thead><th>When we say</th><th>We mean</th></thead>
                      <tr><td>decoding</td><td>parsing</td></tr>
                      <tr><td>validating</td><td>parsing</td></tr>
                      <tr><td>deserializing</td><td>parsing</td></tr>
                      <tr><td>lexing/tokenizing</td><td>parsing</td></tr>
                      <tr><td>pattern matching</td><td>parsing</td></tr>
                    </tbody>
                  </table>
                  <aside class=notes>
                    <p>When we encode, we know we will always succeed.</p>
                    <p>Any time new information is coming into our process from
                      the outside world, we must parse it.</p>
                    <p>The best essay which describes this idea is Parse Don't
                      Validate by Alexis King</p>
                  </aside>
                </section>
                <section data-markdown data-separator-notes="^Notes:">
                What is a parser?

                “a parser is just a function that consumes less-structured input and produces more-structured output.”

                — Alexis King [*Parse, don’t validate*](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)
                </section>
                <section data-markdown>
                A parsing monad has

                * __state__ (position in the input stream)
                * __alternative__ (we can accept either of two patterns here)
                * __failure__ (the input cannot be parsed)
                </section>
                <section>
                <img class=r-stretch data-src="assets/MonadicParsing.png"/>
                <img data-src="assets/Atypeforparsers.png"/>
                <aside class=notes>
                  <p>1998</p>
                  <p>If you think this is too prosaic, there is also a poetic version.</p>
                </aside>
                </section>
                <section>
                <img class=r-stretch data-src="assets/SeussFinal2.jpeg"/>
                <p style="margin:0;">
                — <a href="http://www.willamette.edu/~fruehr/haskell/seuss.html">Fritz Ruehr, Willamette University</a>
                </p>
                <p style="font-size:50%;margin-top:0;">See also <a href="https://vaibhavsagar.com/blog/2018/02/04/revisiting-monadic-parsing-haskell/">Revisiting Monadic Parsing in Haskell</a></p>
                <aside class=notes>
                  <p>Since 1998 we think about this slightly differently, see
                  Vaibhav Sagar's <a href="https://vaibhavsagar.com/blog/2018/02/04/revisiting-monadic-parsing-haskell/">Revisiting Monadic Parsing in Haskell</a></p>
                  <p>But the basic definition and insights still hold.</p>
                </aside>
                </section>
                <section>
                  <h2>Regular Expression</h2>
                  <pre><code data-trim data-noescape>
                  const ayebee = /a(b|B)/;
                  "aB".match(ayebee);
                  </code></pre>
                  <pre><code data-trim data-noescape>
                  'B'
                  </code></pre>
                  <h2>Parser</h2>
                  <pre><code data-trim data-noescape>
                  ayebee :: Parser String Char
                  ayebee = do
                    _ <- char 'a'
                    b <- char 'b' <|> char 'B'
                    pure b

                  runParser "aB" ayebee
                  </code></pre>
                  <pre><code data-trim data-noescape>
                  Right 'B'
                  </code></pre>
                </section>
                <section>
                  <h2>Regular Expression</h2>
                  <pre><code data-trim data-noescape>
                  const ayebee = /a(b|B)/;
                  "aB".match(ayebee);
                  </code></pre>
                  <pre><code data-trim data-noescape>
                  'B'
                  </code></pre>
                  <h2>Parser</h2>
                  <pre><code data-trim data-noescape>
                  ayebee :: Parser String Boolean
                  ayebee = do
                    _ <- char 'a'
                    b <- char 'b' <|> char 'B'
                    pure (b == 'B')

                  runParser "aB" ayebee
                  </code></pre>
                  <pre><code data-trim data-noescap>
                  Right true
                  </code></pre>
                </section>
                <section>
                  <h2>Regular Expression</h2>

                  <p>
                  “99.99%” of RFC 5322 email addresses from http://emailregex.com/
                  </p>

                  <pre><code data-trim data-noescape>
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&
'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-
\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c
\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?
\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]
|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|
2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:
(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|
\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
                  </code></pre>
                </section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				controls: false,
				controlsTutorial: false,
                transition: "none",
				// transition: "slide",
				// transitionSpeed: "fast",
				slideNumber: true,
				fragments: true,
				fragmentInURL: true,
				showNotes: false,
                // highlight: {
                //   beforeHighlight: hljs => hljs.registerLanguage(/*...*/)
                // }
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
